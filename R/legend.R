# legend_timecycle ----

#' Make HCL legend for a cyclical sequence of distributions
#'
#' @param palette data frame containing a color palette generated by
#'   [palette_timecycle].
#' @param specificity logical indicating whether to show a single color wheel or
#'   three wheels demonstrating the palette for specificity values of 0, 50, and
#'   100.
#' @param return_df logical indicating whether to return the legend as a
#'   `ggplot2` object or return a data frame containing the necessary data to
#'   build the legend.
#'
#' @return A ggplot2 plot object of the legend. Alternatively,
#'   `return_df = TRUE` will return a data frame containing a data frame
#'   containing the data needed to build the legend. The data frame columns are:
#'   - `specificity`: amount of variation between layers; mapped to chroma.
#'   - `layer_id`: integer identifying the layer containing the maximum
#'   intensity value; mapped to hue.
#'   - `color`: color associated with the given specificity and peak layer.
#'   - `intensity`: maximum cell value across layers divided by the maximum
#'   value across all layers and cells; mapped to alpha level.
#'
#' @family legend
#' @seealso [legend_timeline] for linear sequences of distributions and
#'   [legend_groups] for distributions of distinct groups.
#' @export
#' @examples
#' # load field sparrow data
#' data(fiespa_occ)
#'
#' # generate hcl palette
#' pal <- palette_timecycle(fiespa_occ)
#'
#' # create legend for palette
#' legend_timecycle(pal)
legend_timecycle <- function(palette, specificity = TRUE, return_df = FALSE) {
  if (!is.data.frame(palette) || !inherits(palette, "palette_timecycle")) {
    stop("palette must be a color palette generated by palette_timecycle().")
  }
  if (!all(c("specificity", "layer_id", "color") %in% names(palette)) ||
      !all(c(0, 50, 100) %in% palette[["specificity"]])) {
    stop("Improperly formatted color palette, try using palette_timecycle().")
  }
  stopifnot(is.logical(specificity), length(specificity) == 1)
  stopifnot(is.logical(return_df), length(return_df) == 1)

  # whether to show 3 or 1 wheels
  if (isTRUE(specificity)) {
    wheel <- palette[palette$specificity %in% c(0, 50, 100), ]
  } else {
    wheel <- palette[palette$specificity == 100, ]
  }

  # add intensity
  wheel <- merge(wheel, data.frame(intensity = seq(0, 1, 0.05)))
  wheel <- wheel[order(wheel[["specificity"]], wheel[["layer_id"]],
                       wheel[["intensity"]]), ]
  row.names(wheel) <- NULL
  class(wheel) <- c("legend_timecycle", "data.frame")

  # return data without plotting if requested
  if (isTRUE(return_df)) {
    return(wheel)
  }

  # make named vector of colors
  tile_colors <- sort(unique(wheel$color))
  names(tile_colors) <- tile_colors

  # make labels for legend
  labs <- c("low", "moderate", "high")
  names(labs) <- c(0, 50, 100)

  # describe ggplot
  p <- ggplot2::ggplot(data = wheel) +
    ggplot2::aes_(x = ~ layer_id, y = ~ intensity, fill = ~ color,
                  alpha = ~ intensity) +
    ggplot2::geom_tile(size = 0) +
    ggplot2::facet_wrap(~ specificity, nrow = 1,
                        labeller = ggplot2::labeller(specificity = labs)) +
    ggplot2::scale_fill_manual(values = tile_colors) +
    ggplot2::scale_alpha_continuous(range = c(0, 1)) +
    ggplot2::coord_polar(theta = "x", start = 0) +
    ggplot2::theme(
      strip.background = ggplot2::element_blank(),
      plot.title = ggplot2::element_text(size = 11, hjust = 0.5),
      panel.grid = ggplot2::element_blank(),
      panel.background = ggplot2::element_blank(),
      panel.spacing = ggplot2::unit(0, "lines"),
      plot.background = ggplot2::element_rect(fill = "white"),
      axis.text = ggplot2::element_blank(),
      axis.ticks = ggplot2::element_blank()) +
    ggplot2::guides(fill = FALSE, alpha = FALSE) +
    ggplot2::ggtitle("Specificity") +
    ggplot2::xlab("Interval") +
    ggplot2::ylab("Maximum\nintensity")

  return(p)
}


# legend_timeline ----

#' Make HCL legend for a linear sequence of distributions
#'
#' @param palette data frame containing a color palette generated by
#'   [palette_timeline].
#' @param specificity logical indicating whether to show a single legend or
#'   three legend demonstrating the palette for specificity values of 0, 50, and
#'   100.
#' @param time_labels character vector with two elements to be used as labels
#'   for the start and end points of the time axis (i.e. x-axis) in the legend.
#' @param return_df logical indicating whether to return the legend as a
#'   `ggplot2` object or return a data frame containing the necessary data to
#'   build the legend.
#'
#' @return A ggplot2 plot object of the legend. Alternatively,
#'   `return_df = TRUE` will return a data frame containing a data frame
#'   containing the data needed to build the legend. The data frame columns are:
#'   - `specificity`: amount of variation between layers; mapped to chroma.
#'   - `layer_id`: integer identifying the layer containing the maximum
#'   intensity value; mapped to hue.
#'   - `color`: color associated with the given specificity and peak layer.
#'   - `intensity`: maximum cell value across layers divided by the maximum
#'   value across all layers and cells; mapped to alpha level.
#'
#' @family legend
#' @seealso [legend_timecycle] for cyclical sequences of distributions and
#'   [legend_groups] for distributions of distinct groups.
#' @export
#' @examples
#' # load elephant data
#' data(elephant_ud)
#'
#' # generate hcl palette
#' pal <- palette_timeline(elephant_ud)
#'
#' # create legend for palette
#' legend_timeline(pal)
legend_timeline <- function(palette, specificity = TRUE,
                            time_labels = NULL, return_df = FALSE) {
  if (!is.data.frame(palette) || !inherits(palette, "palette_timeline")) {
    stop("palette must be a color palette generated by palette_timeline().")
  }
  if (!all(c("specificity", "layer_id", "color") %in% names(palette)) ||
      !all(c(0, 50, 100) %in% palette[["specificity"]])) {
    stop("Improperly formatted color palette, try using palette_timeline().")
  }
  stopifnot(is.logical(specificity), length(specificity) == 1)
  if (!is.null(time_labels)) {
    stopifnot(is.character(time_labels), length(time_labels) == 2)
  }
  stopifnot(is.logical(return_df), length(return_df) == 1)

  # whether to show 3 or 1 wheels
  if (isTRUE(specificity)) {
    wheel <- palette[palette$specificity %in% c(0, 50, 100), ]
  } else {
    wheel <- palette[palette$specificity == 100, ]
  }

  # add intensity
  wheel <- merge(wheel, data.frame(intensity = seq(0, 1, 0.05)))
  wheel <- wheel[order(wheel[["specificity"]], wheel[["layer_id"]],
                       wheel[["intensity"]]), ]
  class(wheel) <- c("legend_timeline", "data.frame")

  # return data without plotting if requested
  if (isTRUE(return_df)) {
    return(wheel)
  }

  # make named vector of colors
  tile_colors <- sort(unique(wheel$color))
  names(tile_colors) <- tile_colors

  # make labels for legend
  wheel$specificity <- factor(wheel$specificity, levels = c(100, 50, 0))
  labs <- c("Low specificity", "Moderate specificity", "High specificity")
  names(labs) <- c(0, 50, 100)

  # describe ggplot
  p <- ggplot2::ggplot(data = wheel) +
    ggplot2::aes_(x = ~ layer_id, y = ~ intensity, fill = ~ color,
                  alpha = ~ intensity) +
    ggplot2::geom_tile(size = 0) +
    ggplot2::facet_wrap(~ specificity, ncol = 1,
                        labeller = ggplot2::labeller(specificity = labs)) +
    ggplot2::scale_x_continuous(breaks = c(1, max(palette[["layer_id"]])),
                                labels = time_labels) +
    ggplot2::scale_fill_manual(values = tile_colors) +
    ggplot2::scale_alpha_continuous(range = c(0, 1)) +
    ggplot2::theme(strip.background = ggplot2::element_blank(),
                   panel.grid = ggplot2::element_blank(),
                   panel.background = ggplot2::element_blank(),
                   panel.spacing = ggplot2::unit(0, "lines"),
                   plot.background = ggplot2::element_rect(fill = "white"),
                   plot.title = ggplot2::element_text(size = 11, hjust = 0.5),
                   axis.text.y = ggplot2::element_blank(),
                   axis.ticks = ggplot2::element_blank(),
                   aspect.ratio = 0.4) +
    ggplot2::guides(fill = FALSE, alpha = FALSE) +
    ggplot2::xlab("Interval") +
    ggplot2::ylab("Maximum\nintensity")

  return(p)
}

# legend_groups ----

#' Make HCL legend for the distributions of distinct groups
#'
#' @param palette data frame containing a color palette generated by
#'   [palette_groups].
#' @param specificity logical indicating whether to visualize the variation in
#'   intensity in the legend or to fix intensity at 100.
#' @param group_labels character vector with two elements to be used as labels
#'   for the start and end points of the time axis (i.e. x-axis) in the legend.
#' @param return_df logical indicating whether to return the legend as a
#'   `ggplot2` object or return a data frame containing the necessary data to
#'   build the legend.
#'
#' @return A ggplot2 plot object of the legend. Alternatively,
#'   `return_df = TRUE` will return a data frame containing a data frame
#'   containing the data needed to build the legend. The data frame columns are:
#'   - `specificity`: amount of variation between layers; mapped to chroma.
#'   - `layer_id`: integer identifying the layer containing the maximum
#'   intensity value; mapped to hue.
#'   - `color`: color associated with the given specificity and peak layer.
#'   - `intensity`: maximum cell value across layers divided by the maximum
#'   value across all layers and cells; mapped to alpha level.
#'
#' @family legend
#' @seealso [legend_timecycle] for cyclical sequences of distributions and
#'   [legend_timeline] for linear sequences of distributions.
#' @export
#' @examples
#' # load elephant data
#' data(elephant_ud)
#' # treat layers as groups of elephants, not years for a single elephant
#' names(elephant_ud) <- paste0("group", 1:4)
#'
#' # generate hcl palette
#' pal <- palette_groups(elephant_ud)
#'
#' # create legend for palettes
#' legend_groups(pal)
legend_groups <- function(palette, specificity = TRUE, group_labels = NULL,
                          return_df = FALSE) {
  if (!is.data.frame(palette) || !inherits(palette, "palette_groups")) {
    stop("palette must be a color palette generated by palette_groups().")
  }
  if (!all(c("specificity", "layer_id", "color") %in% names(palette)) ||
      !all(c(0, 50, 100) %in% palette[["specificity"]])) {
    stop("Improperly formatted color palette, try using palette_groups().")
  }
  stopifnot(is.logical(specificity), length(specificity) == 1)
  if (!is.null(group_labels)) {
    stopifnot(is.character(group_labels),
              length(group_labels) == length(unique(palette[["layer_id"]])))
  }
  stopifnot(is.logical(return_df), length(return_df) == 1)

  # whether to show 3 or 1 wheels
  if (isTRUE(specificity)) {
    wheel <- palette[palette$specificity %in% c(0, 50, 100), ]
  } else {
    wheel <- palette[palette$specificity == 100, ]
  }

  # add intensity
  wheel <- merge(wheel, data.frame(intensity = seq(0, 1, 0.01)))
  wheel <- wheel[order(wheel[["specificity"]], wheel[["layer_id"]],
                       wheel[["intensity"]]), ]
  row.names(wheel) <- NULL
  class(wheel) <- c("legend_groups", "data.frame")

  # return data without plotting if requested
  if (isTRUE(return_df)) {
    return(wheel)
  }

  # make named vector of colors
  tile_colors <- sort(unique(wheel$color))
  names(tile_colors) <- tile_colors

  # make labels for groups
  unique_ids <- sort(unique(palette[["layer_id"]]))
  if (is.null(group_labels)) {
    group_labels <- unique_ids
    names(group_labels) <- unique_ids
  } else {
    names(group_labels) <- unique_ids
  }

  # describe ggplot
  p <- ggplot2::ggplot(data = wheel) +
    ggplot2::aes_(x = ~ specificity, y = ~ intensity, fill = ~ color,
                  alpha = ~ intensity) +
    ggplot2::geom_tile(size = 0) +
    ggplot2::facet_wrap(~ layer_id, ncol = length(unique_ids),
                        labeller = ggplot2::labeller(layer_id = group_labels)) +
    ggplot2::scale_fill_manual(values = tile_colors) +
    ggplot2::scale_alpha_continuous(range = c(0, 1)) +
    ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5, size = 11),
                   strip.background = ggplot2::element_blank(),
                   panel.grid = ggplot2::element_blank(),
                   panel.background = ggplot2::element_rect(fill = "white"),
                   panel.spacing = ggplot2::unit(0, "lines"),
                   plot.background = ggplot2::element_rect(fill = "white"),
                   aspect.ratio = 1,
                   axis.text = ggplot2::element_blank(),
                   axis.ticks = ggplot2::element_blank()) +
    ggplot2::guides(fill = FALSE, alpha = FALSE) +
    ggplot2::xlab("Specificity") +
    ggplot2::ylab("Maximum\nintensity")

  return(p)
}
